* Introduction
This document contains my configuration on vanilla =Emacs= using the principles of =Literate Programming=.
Literate programming allows us to be more expressive and deliberate.
Not only we can use typography to its maximum potential,
but can also employ techniques such as internal links between sections.
This makes the end product much better for end users, than a terse script.
This document is created using =Org-mode= which now ships with =Emacs= as a built-in mode.

* Basic setup
** Store timestamp
#+BEGIN_SRC emacs-lisp
(defvar init-timestamp (float-time))
#+END_SRC
** Package manager setup
#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil)
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (setq straight-use-package-by-default t)
#+END_SRC
** Install use-package
#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC
** Tweak GC
#+BEGIN_SRC emacs-lisp
  (defvar amirreza/gc-cons-threshold 16777216)
  (setq gc-cons-threshold most-positive-fixnum
	gc-cons-percentage 0.6)

  (add-hook 'emacs-startup-hook
	    (lambda ()
	      (setq gc-cons-threshold amirreza/gc-cons-threshold)
	      gc-cons-percentage 0.1))

  (defun defer-garbage-collection-h ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun restore-garbage-collection-h ()
    (run-at-time
     1 nil (lambda () (setq gc-cons-threshold amirreza/gc-cons-threshold))))

  (add-hook 'minibuffer-setup-hook #'defer-garbage-collection-h)
  (add-hook 'minibuffer-exit-hook #'restore-garbage-collection-h)

  (use-package gcmh
    :config
    (setq gcmh-idle-delay 10
	  gcmh-high-cons-threshold amirreza/gc-cons-threshold
 	  gc-cons-percentage 0.1))
#+END_SRC
** Empty file handlers variable at startup
#+BEGIN_SRC emacs-lisp
(defvar --file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(add-hook 'emacs-startup-hook
	  (lambda ()
	    (setq file-name-handler-alist --file-name-handler-alist)))
#+END_SRC
** Start in fundamental mode
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'fundamental-mode)
#+END_SRC

** Disable GUI shits
Emacs GUI starts up with a =menu-bar=, =tool-bar= and =scroll-bar= which I think literally 
nobody is using.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
(scroll-bar-mode 0)
(menu-bar-mode 0)
(setq use-dialog-box nil)
#+END_SRC
** Turn off startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen 0)
#+END_SRC
** Prevent Emacs from medling with =init.el=
=Emacs= has a package called =Customize= which stores some information about the theme, and installed packages
in the init.el file but I put all my emacs configuration in a git repo so I need to prevent this
from happening. 
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
#+END_SRC
** Turn off annoying ring
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
** Font settings
I don't have a default font but I use =Jetbrains Mono=, =Fira Code= and =Hack= font 
almost all the time.
#+BEGIN_SRC emacs-lisp
  (defun amirreza/font (font size)
    (add-to-list 'default-frame-alist (cons 'font (format "%s-%d" font size))))
(amirreza/font "Jetbrains Mono" 12)
#+END_SRC

** y-or-n
Emacs asks yes/no questions in minibuffer an you need to type yes or no completely which
is kind of annoying.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Use PATH from OS
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell :config (exec-path-from-shell-initialize))
#+END_SRC
* Themes, Icons
** Themes
Let's install some themes :) and ofcourse use one of them.
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes :defer t)
  (use-package spacemacs-theme :defer t)
  (use-package badwolf-theme :defer t)
  (use-package modus-operandi-theme :defer t) ;; light version of modus theme
  (use-package modus-vivendi-theme :defer t) ;; dark version of modus theme
  (load-theme 'doom-one t)

#+END_SRC
** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons :commands 
  :commands (all-the-icons-octicon
             all-the-icons-faicon
             all-the-icons-fileicon
             all-the-icons-wicon
             all-the-icons-material
             all-the-icons-alltheicon))
(use-package all-the-icons-dired
  :init
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
** Modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :init (doom-modeline-mode 1))
(setq doom-modeline-height 35)
#+END_SRC
* Completion and narrowing framework
** Code Completion (company)
=Company-mode= in Emacs is the package I use to add code-completion to my Emacs.
It's neat package with great architecture, basically =company= is made from two parts
=company-backends= and =company-frontend=, =company-backends= are a list of backends 
and backends are modules that can provide company with completion candidates and 
=company-frontend= is how company shows those completions to me which I use the default
one.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :custom
    (company-idle-delay 0.25)
    (company-minimum-prefix-length 2)
    (company-tooltip-limit 14)
    (company-tooltip-align-annotations t)
    (company-require-match 'never)
    (company-global-modes '(not erc-mode message-mode help-mode gud-mode eshell-mode))
    (company-backends  '(company-capf))
    (company-frontends '(company-pseudo-tooltip-frontend
                        company-echo-metadata-frontend))
    :config
    (global-company-mode 1)
    (add-to-list 'company-backends '(company-capf company-dabbrev)))

#+END_SRC
** Ivy
When using =Emacs= a task you probably do a thousand times is to find something in =minibuffer= 
out of multiple choices that you have, basic =Emacs= is not that productive because of that there
are multiple packages in community that help you do these kind of tasks simpler, the one that I
use daily is called =ivy= which is basically a framework for narrowing down candidates, but it comes
with a general frontend called =counsel= which provides replacement functions for default Emacs 
functions like =find-file= and others you can see the ones I use in the code block below and
a =C-s= replacement tool call swiper.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :bind
    (("C-x b" . 'ivy-switch-buffer))
    :custom
    (ivy-height 17)
    (ivy-wrap t)
    (ivy-fixed-height-minibuffer t)
    (projectile-completion-system 'ivy)
    ;; disable magic slash on non-match
    (ivy-magic-slash-non-match-action nil)
    ;; don't show recent files in switch-buffer
    (ivy-use-virtual-buffers nil)
    ;; ...but if that ever changes, show their full path
    (ivy-virtual-abbreviate 'full)
    ;; don't quit minibuffer on delete-error
    (ivy-on-del-error-function #'ignore)
    ;; enable ability to select prompt (alternative to `ivy-immediate-done')
    (ivy-use-selectable-prompt t)
    :config
    (setf (alist-get 't ivy-format-functions-alist)
	  #'ivy-format-function-line)
    (ivy-mode +1))

    (use-package swiper
    :commands (swiper)
    :init (global-set-key (kbd "C-s") 'swiper))

  (use-package counsel
    :commands (counsel-M-x counsel-find-file ivy-switch-buffer)
    :bind
    (("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("C-h b" . 'counsel-descbinds)
     ("C-h f" . 'counsel-describe-function)
     ("C-h v" . 'counsel-describe-variable)
     ("C-h a" . 'counsel-apropos)
     ("<f4>"  . 'counsel-fzf)
     ("M-y" . 'counsel-yank-pop)))

#+END_SRC
* Improve general editor experience
** General keybindings
#+BEGIN_SRC emacs-lisp
  ;; disabling some useless annoying keys
  (global-set-key (kbd "C-z") nil)
  (global-set-key (kbd "M-z") nil)
  (global-set-key (kbd "C-x C-z") nil)

  ;; sane zoom-in and zoom-out 
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C-_") 'text-scale-decrease)
#+END_SRC
** Which Key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode 1))
#+END_SRC
** Custom motions
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-n") (lambda () (interactive) (next-line 5)))
  (global-set-key (kbd "M-p") (lambda () (interactive) (previous-line 5)))
#+END_SRC
** IBuffer
Emacs built-in funtion called =list-buffers= is not that much productive, luckily Emacs now ships
with =Ibuffer= package which is an interactive way to manage you buffers and provide a =magit= 
like user-interface.
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind (("C-x C-b" . 'ibuffer)))
  (use-package ibuffer-vc :disabled t)
  (use-package ibuffer-projectile 
    :hook (ibuffer . ibuffer-projectile-set-filter-groups))
#+END_SRC
** Dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :straight nil
    :bind
    (("C-x C-j" . dired-jump)
     ("C-x j" . dired-jump-other-window))
    :custom
    ;; Always delete and copy recursively
    (dired-recursive-deletes 'always)
    (dired-recursive-copies 'always))
#+END_SRC
** Winner mode
#+BEGIN_SRC emacs-lisp
  (use-package winner 
    :ensure nil
    :straight nil)
#+END_SRC
** IEdit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :bind (("C-;" . 'iedit-mode)))
#+END_SRC
** Treemacs
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :disabled t
    :bind (("M-0" . treemacs-select-window))
    :init
    (setq treemacs-follow-after-init t
	  treemacs-is-never-other-window nil
	  treemacs-sorting 'alphabetic-case-insensitive-asc)
    :config 
    (treemacs-follow-mode -1))
  (use-package treemacs-projectile :disabled t)
  (use-package treemacs-magit :disabled t)
#+END_SRC
** Crux
Crux is a collection of useful emacs functions.
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :bind (("C-S-k" . 'crux-kill-whole-line)
	   ("C-x K" . 'crux-kill-other-buffers)))
#+END_SRC
** Centaur-Tabs
#+BEGIN_SRC emacs-lisp
  (use-package centaur-tabs
    :disabled t
    :init
    (setq centaur-tabs-set-icons t
	  centaur-tabs-gray-out-icons 'buffer
	  centaur-tabs-set-bar 'left
	  centaur-tabs-set-modified-marker t
	  centaur-tabs-close-button "✕"
	  centaur-tabs-modified-marker "⬤")
    :config
    (centaur-tabs-mode 1))
#+END_SRC
** Line numbers
=Emacs= has the minor mode for showing line numbers but it is not enabled by default so let's enable
it to show line numbers every where.
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode 1)
#+END_SRC
** Column number mode
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
** Cursor shape
Emacs default cursor is in the shape of the box and it covers the current char under it so 
let's change it. 
#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

** Current line highlight
Only personal preference no factual reason behind it.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC
** Stop blinking cursor
It distracts my eyes.
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC
** Multiple cursors support
I'm not a fan of multiple cursors myself but sometimes they are the simplest way possible.
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :defer t
    :bind (("C->" . 'mc/mark-next-like-this)
	   ("C-<" . 'mc/mark-previous-like-this)
	   ("C-c C-<" . 'mc/mark-all-like-this)
	   ("C-M-," . 'mc/edit-lines)))
#+END_SRC
** Expand region
expand region is package that helps you expand/ a selected text region based
on semantics.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("C-=" . 'er/expand-region)
	   ("C--" . 'er/contract-region)))
#+END_SRC
** Improve Scrolling Experience
#+BEGIN_SRC emacs-lisp
;; Vertical Scroll
(setq scroll-step 1)
(setq scroll-margin 1)
(setq scroll-conservatively 101)
(setq scroll-up-aggressively 0.01)
(setq scroll-down-aggressively 0.01)
(setq auto-window-vscroll nil)
(setq fast-but-imprecise-scrolling nil)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-progressive-speed nil)
;; Horizontal Scroll
(setq hscroll-step 1)
(setq hscroll-margin 1)
#+END_SRC
** Highlight Indents
This is a must have for me when I'm reading/writing yaml files since I always lose track
of where I am in the data tree.
#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :hook ((yaml-mode) . highlight-indent-guides-mode)
  :init
  (setq highlight-indent-guides-method 'character)
  :config
  (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces))
#+END_SRC
** Ace window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind (("C-x o" . 'ace-window) 
	   ("C-x C-o" . 'ace-window)))
#+END_SRC
** Header for new files
Emacs comes with a package called =auto-insert= which inserts headers for new files when you
create them.
#+BEGIN_SRC emacs-lisp
(auto-insert-mode 1)
#+END_SRC
** Ripgrep (Better faster grep)
Emacs users always had the goal of living inside Emacs, and how you can live inside Emacs 
without =grep=. I'm using counsel-projectile-rg instead of this but it's here for percaution.
#+BEGIN_SRC emacs-lisp
  (use-package rg
    :disabled t
    :commands (rg))
#+END_SRC
** cTags
If you are familiar with =ctags= you know how much power lies behind
such a simple program, while some language servers are not ready for big projects
(talking to you gopls) I am going to have ctags feature in my Emacs.
#+BEGIN_SRC emacs-lisp
  (defun update-ctags ()
    "Update Ctags file in current directory."
    (interactive)
    (cd default-directory)
    (start-process "ctags" "*CTAGS*" "ctags" "-eR" "."))
#+END_SRC
** FZF (fuzzy-file-finder)
Fuzzy file search, but I use =counsel-fzf= since it has the best match for all of my workflow.
#+BEGIN_SRC emacs-lisp
  (use-package fzf
    :disabled t
    :commands (fzf)
    :bind(("<f3>" . 'fzf)))
#+END_SRC
** Sudo edit
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :commands (sudo-edit))
#+END_SRC
** Org-mode
#+BEGIN_SRC emacs-lisp
    (use-package org
      :ensure nil
      :straight nil
      :custom
      (org-support-shift-select t))

    (use-package org-bullets
      :hook ((org-mode) . 'org-bullets-mode))
#+END_SRC
** hl-todo
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :hook (prog-mode . hl-todo)
    :config
    (setq hl-todo-highlight-punctuation ":"
	  hl-todo-keyword-faces
	  `(("TODO"       warning bold)
	    ("FIXME"      error bold)
	    ("HACK"       font-lock-constant-face bold)
	    ("REVIEW"     font-lock-keyword-face bold)
	    ("NOTE"       success bold)
	    ("DEPRECATED" font-lock-doc-face bold))))
#+END_SRC
* Development Environment
** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind
    (("C-x p" . 'projectile-command-map)
     ("C-c p" . 'projectile-add-known-project))
    :custom
    (projectile-completion-system 'ivy)
    :config
    (projectile-mode 1)
    (add-to-list 'projectile-globally-ignored-directories "node_modules"))

  (use-package counsel-projectile
    :bind (("<f2>" . counsel-projectile-rg)))

#+END_SRC
** Syntax checker and linter
Syntax checking in my Emacs happens with the help of =Flycheck=, which does the linting
and shows warnings or errors about the code and major modes can hook into it and provide
language specific comments. I enable flycheck for all programming languages using =prog-mode=
hook which basically covers all programming major modes.
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (flymake-mode 0)))

(use-package flycheck :hook (prog-mode . flycheck-mode))
#+END_SRC
** Language Server Protocol
=Company= gives us the infrastructre that we need for code completion but we need
backends to feed it the completion candidates. There are specific backends for almost 
all languages but I use LSP for everything, =LSP= or =LanguageServerProtocol= is a protocol
developed by microsoft for =VSCode= but it's not limited to Microsoft and now it has huge
community, multiple enterprises like =RedHat= and =Sourcegraph= behind it and support
for almost all languages.
[[List of supported langauges][https://langserver.org/#implementations-server]] 
[[https://github.com/emacs-lsp/lsp-mode#supported-languages]]
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :hook ((prog-mode) . lsp)
    :init
    ;; Guess root with the help of `projectile`
    (setq lsp-auto-guess-root t)
    ;; Kill Lsp server when last buffer associated with that server killed
    (setq lsp-keep-workspace-alive nil)
    ;; disable unncessary stuff
    (setq lsp-enable-folding nil
        ;; Potentially slow
        lsp-enable-file-watchers nil
        lsp-enable-text-document-color nil
        lsp-enable-semantic-highlighting nil
        ;; Don't modify our code without our permission
        lsp-enable-indentation nil
        lsp-enable-on-type-formatting nil)
    :commands
    (lsp lsp-install-server))

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :config
    (setq lsp-ui-doc-max-height 8
        lsp-ui-doc-max-width 35
        lsp-ui-sideline-ignore-duplicate t
        ;; lsp-ui-doc is redundant with and more invasive than
        ;; `+lookup/documentation'
        lsp-ui-doc-enable nil
        ;; Don't show symbol definitions in the sideline. They are pretty noisy,
        ;; and there is a bug preventing Flycheck errors from being shown (the
        ;; errors flash briefly and then disappear).
        lsp-ui-sideline-show-hover nil)
    :commands (lsp-ui-mode))

  (use-package lsp-ivy
    :commands (lsp-ivy-workspace-symbol lsp-ivy-global-workspace-symbol))

  ;; company backend to hook LSP to company
  (use-package company-lsp
    :config
    (setq company-lsp-cache-candidates 'auto)
    :commands (company-lsp))


#+END_SRC
** Dumb jump
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :bind
    (("C-M-j" . 'dumb-jump-go)
     ("C-M-p" . 'dumb-jump-back))
    :config
    (dumb-jump-mode 1))
#+END_SRC
** Git
=magit= is the git wrapper I have seen out then, I have seen =vim-fugitive=, =Jetbrains
IDEA=, =VSCode+Gitlens=, but still =magit= is the best.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands (magit-status)
    :bind
    (("C-x g" . 'magit-status)))

  (use-package diff-hl :config (global-diff-hl-mode 1))

  (use-package gitconfig-mode :mode "/\\.gitconfig\\'")

  (use-package gitignore-mode
    :mode "/\\.gitignore\\'")

  (use-package gitattributes-mode
    :mode "/\\.gitattributes\\'")

  (use-package git-messenger
    :bind
    (("C-M-c" . 'git-messenger:popup-message))
    :config
    (setq git-messenger:show-detail t)
    (setq git-messenger:use-magit-popup t))

#+END_SRC
** Programming Languages
Support for every programming language I have ever used.
#+BEGIN_SRC emacs-lisp
  ;; C language server
  (use-package cquery :defer t)


  (use-package mips-mode :defer t)

  (use-package fsharp-mode :mode "\\.fs\\'")

  (use-package csharp-mode :mode "\\.cs\\'")

  (use-package nasm-mode :defer t)

  (use-package haxor-mode :mode "\\.hax\\'")

  (use-package json-mode
    :mode "\\.json\\'"
    :config
    (add-hook 'before-save-hook 'json-mode-beautify))

  (use-package yaml-mode
    :mode
    "\\.ya?ml\\'")

  (use-package toml-mode
    :mode "\\.toml\\'")

  (use-package csv-mode
    :mode "\\.csv\\'")

  (use-package protobuf-mode
    :mode "\\.proto\\'")


  (use-package markdown-mode
    :mode "\\.md\\'")

  (use-package go-mode
    :mode "\\.go\\'"
    :init
    (add-hook 'go-mode-hook (lambda () (add-to-list 'exec-path (concat (getenv "HOME") "/go/bin"))))
    :config
    (add-hook 'before-save-hook 'gofmt-before-save)
    (add-hook 'before-save-hook 'go-import-add)
    (add-hook 'before-save-hook 'go-remove-unused-import)
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))

  (use-package go-add-tags :defer t)

  (use-package gotest :defer t)


  (use-package haskell-mode
    :mode "\\.hs\\'")

  (use-package lsp-haskell
    :hook haskell-mode)

  (use-package scala-mode
    :mode "\\.scala\\'")

  (use-package sbt-mode
    :hook scala-mode)

  (use-package python-mode
    :mode "\\.py\\'")

  (use-package pipenv
    :defer t)

  (use-package lsp-python-ms
    :defer t)

  (use-package py-autopep8
    :hook python-mode)

  (use-package elixir-mode
    :mode "\\.ex\\'")

  (use-package alchemist
    :defer t)

  (use-package rust-mode
    :mode "\\.rs\\'")

  (use-package flycheck-rust
   :mode "\\.rs\\'"
   :init (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
   :hook rust-mode)

  (use-package cargo
    :mode "\\.rs\\'"
    :init (add-hook 'rust-mode-hook #'cargo-minor-mode))

  ;; Common Lisp environment
  (use-package sly
    :hook lisp-mode)

  (use-package paredit
    :hook ((emacs-lisp-mode clojure-mode) . paredit-mode))


  (use-package parinfer
    :hook ((emacs-lisp-mode clojure-mode) . parinfer-mode))

  (use-package rainbow-delimiters
    :hook ((prog-mode) . rainbow-delimiters-mode))

  (use-package clojure-mode
    :mode "\\.cljs?\\'")

  (use-package cider
    :mode "\\.cljs?\\'"
    :bind (:map cider-mode-map
		("C-x C-e" . 'cider-eval-last-sexp)))

  (use-package lua-mode
    :mode "\\.lua\\'")

  (use-package php-mode
    :mode "\\.php\\'")

  (use-package phpunit
    :bind
    (("C-c C-t t" . phpunit-current-test)
     ("C-c C-t c" . phpunit-current-class)
     ("C-c C-t p" . phpunit-current-project)))

  (use-package js2-mode
    :hook js-mode)

  (use-package tide
    :mode "\\.ts\\'")

  (use-package web-mode
    :mode ("\\.html\\'" "\\.css\\'"))

  (use-package dockerfile-mode
    :mode "Dockerfile")

  (use-package groovy-mode
    :mode ("\\.gradle\\'" "\\.groovy\\'"))

  (use-package gradle-mode
    :mode "\\.gradle\\'")

  (add-hook 'java-mode-hook (lambda ()
			      (c-set-offset 'arglist-intro '+)
			      (setq java-basic-offset 2)
			      (setq c-basic-offset 2)))

  (use-package lsp-java
    :hook (java-mode))

  (use-package racket-mode
    :mode "\\.rkt\\'")


#+END_SRC
* Operations Environment
Recently I started using Emacs for opertion tasks.
** Kubernetes
#+BEGIN_SRC emacs-lisp
  (use-package kubel
    :commands
    (kubel))
#+END_SRC
** Docker
#+BEGIN_SRC emacs-lisp
  (use-package docker
    :bind
    ("C-c d" . docker))

#+END_SRC
** Ansible
#+BEGIN_SRC emacs-lisp
  (use-package ansible
    :commands ansible-auto-decrypt-encrypt
    :init
    (put 'ansible-vault-password-file 'safe-local-variable #'stringp)
    :config
    (setq ansible-section-face 'font-lock-variable-name-face
	  ansible-task-label-face 'font-lock-doc-face))
  (use-package jinja2-mode
    :mode "\\.j2$")

#+END_SRC
* Gnus setup
Emacs =Gnus= basic setup for Gmail.
#+BEGIN_SRC emacs-lisp
  (use-package gnus
    :straight nil
    :ensure nil
    :defer t
    :commands (gnus)
    :config
    (setq user-mail-address "raskarpour@gmail.com"
	  user-full-name "amirrezaask")
  
    (setq gnus-select-method
	  '(nnimap "gmail"
		   (nnimap-address "imap.gmail.com")
		   (nnimap-server-port "imaps")
		   (nnimap-stream ssl)))
    (setq smtpmail-smtp-server "smtp.gmail.com"
	  smtpmail-smtp-service 587
	  gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]"))

#+END_SRC
* Window manager
Emacs is so extensible that you can use it as a X window manager using =exwm= package which is a wrapper around =xeldb=.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :disabled t
    :config
    (require 'exwm)
    (require 'exwm-config)
    (exwm-config-default)
    (display-battery-mode 1)
    (defun exwm-current-workspace ()
      (interactive)
      (message "Current workspace is %s" exwm-workspace-current-index))
    (add-hook 'exwm-workspace-switch-hook 'exwm-current-workspace)
    :bind
    (("C-c C-w n" . 'exwm-current-workspace)
     ("C-x /" . 'exwm-input-toggle-keyboard)))

#+END_SRC

* Benchmark
#+BEGIN_SRC emacs-lisp
(message "Startup took %s" (- (float-time) init-timestamp))
#+END_SRC
