* Introduction
This document contains my configuration on vanilla =Emacs= using the principles of =Literate Programming=.
Literate programming allows us to be more expressive and deliberate.
Not only we can use typography to its maximum potential,
but can also employ techniques such as internal links between sections.
This makes the end product much better for end users, than a terse script.
This document is created using =Org-mode= which now ships with =Emacs= as a built-in mode.

* Basic setup
** Tweak GC
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold most-positive-fixnum; 2^61 bytes
      gc-cons-percentage 0.6)

(add-hook 'emacs-startup-hook
	  (lambda ()
	    (setq gc-cons-threshold 16777216 ; 16mb
		  gc-cons-percentage 0.1)))
(defun defer-garbage-collection-h ()
  (setq gc-cons-threshold 16777216))


(defun restore-garbage-collection-h ()
  (run-at-time
   1 nil (lambda () (setq gc-cons-threshold most-positive-fixnum))))

(add-hook 'minibuffer-setup-hook #'defer-garbage-collection-h)
(add-hook 'minibuffer-exit-hook #'restore-garbage-collection-h)
#+END_SRC
** Empty file handlers variable at startup
#+BEGIN_SRC emacs-lisp
(defvar --file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(add-hook 'emacs-startup-hook
	  (lambda ()
	    (setq file-name-handler-alist --file-name-handler-alist)))
#+END_SRC
** Start in fundamental mode
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'fundamental-mode)
#+END_SRC
** Package manager setup
#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))

;; Initialise the packages, avoiding a re-initialisation.
(unless (bound-and-true-p package--initialized)
  (setq package-enable-at-startup nil)
  (package-initialize))

#+END_SRC
** Install use-package
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

(eval-when-compile
  (require 'use-package))

#+END_SRC
** Always rebuild
When =Emacs= wants to evaluate an =Org= file it creates a corresponding document with the same
name but different extension for example for this file it creates a =README.el= containing all 
=elisp= codes together, so to make sure we always are using the latest version of our configurations
we delete the file on =Emacs= shutting down.
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (defun amirreza/delete-this-file ()
    (interactive)
    (let ((configs "~/.emacs.d/README.el"))
      (when configs
        (delete-file configs))))
  :hook (kill-emacs . amirreza/delete-this-file))
#+END_SRC
** Disable GUI shits
Emacs GUI starts up with a =menu-bar=, =tool-bar= and =scroll-bar= which I think literally 
nobody is using.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
(scroll-bar-mode 0)
(menu-bar-mode 0)
(setq use-dialog-box nil)
#+END_SRC
** Turn off startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen 0)
#+END_SRC
** Prevent Emacs from medling with =init.el=
=Emacs= has a package called =Customize= which stores some information about the theme, and installed packages
in the init.el file but I put all my emacs configuration in a git repo so I need to prevent this
from happening. 
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
#+END_SRC
** Turn off annoying ring
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
** Font settings
I don't have a default font but I use =Jetbrains Mono=, =Fira Code= and =Hack= font 
almost all the time.
#+BEGIN_SRC emacs-lisp
  (defun amirreza/font (font size)
    (add-to-list 'default-frame-alist (cons 'font (format "%s-%d" font size))))

(amirreza/font "Jetbrains Mono" 12)
#+END_SRC

** y-or-n
Emacs asks yes/no questions in minibuffer an you need to type yes or no completely which
is kind of annoying.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Use PATH from OS
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell :config (exec-path-from-shell-initialize))
#+END_SRC
* Completion and narrowing framework
** Icomplete
=Icomplete= is probably the oldest completion framework out there, it was first released in the 90s and out of the box it can not compete with other options like =Ido= or third 
party ones like =Ivy= or =Helm=. To get the best possible result from =Icomplete= we need to customize the =minibuffer= as well.
#+BEGIN_SRC emacs-lisp
  ;; (eval-and-compile 'minibuffer
  ;;       (setq completion-casere-case t)
  ;;       (setq completion-styles '(flex))) ;; emacs 27 only

  (use-package icomplete
    :disabled t
    :config
    (icomplete-mode 1))
#+END_SRC
** Ido
Ido mode is a built-in completion and narrowing framework for Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package ido
    :config
    (ido-mode 1)
    (ido-everywhere 1)
    (setq ido-enable-flex-matching t))

  (use-package ido-at-point
     :config
     (ido-at-point-mode 1)
     (global-set-key (kbd "M-;") 'completion-at-point))

  (use-package ido-vertical-mode
    :disabled t
    :config
    (ido-vertical-mode 1)
    (setq ido-vertical-define-keys 'C-n-and-C-p-only))

  (use-package ido-completing-read+
    :config
    (ido-ubiquitous-mode 1))
#+END_SRC
** Ivy
When using =Emacs= a task you probably do a thousand times is to find something in =minibuffer= 
out of multiple choices that you have, basic =Emacs= is not that productive because of that there
are multiple packages in community that help you do these kind of tasks simpler, the one that I
use daily is called =ivy= which is basically a framework for narrowing down candidates, but it comes
with a general frontend called =counsel= which provides replacement functions for default Emacs 
functions like =find-file= and others you can see the ones I use in the code block below and
a =C-s= replacement tool call swiper.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
  :disabled
    :bind
    (("C-x b" . 'ivy-switch-buffer)))

  (use-package ivy-posframe
  :disabled
    :config
    (setq ivy-posframe-height-alist
	  '((swiper . 15)
	    (swiper-isearch . 15)
	    (t . 10)))
    (setq ivy-posframe-display-functions-alist
	  '((swiper . nil)
	    (swiper-isearch . nil)
	    (t . ivy-posframe-display-at-frame-center)))
    (ivy-posframe-mode 1))

  (use-package swiper
  :disabled
    :commands (swiper)
    :init (global-set-key (kbd "C-s") 'swiper))

  (use-package counsel
  :disabled
    :commands (counsel-M-x counsel-find-file ivy-switch-buffer)
    :bind
    (("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("C-h b" . 'counsel-descbinds)
     ("C-h f" . 'counsel-describe-function)
     ("C-h v" . 'counsel-describe-variable)
     ("C-h a" . 'counsel-apropos)
     ("<f2> " . 'counsel-ag)
     ( "M-y" . 'counsel-yank-pop)))

#+END_SRC

* Improve general editor experience
** Buffer switching (ibuffer)
Emacs built-in funtion called =list-buffers= is not that much productive, luckily Emacs now ships
with =Ibuffer= package which is an interactive way to manage you buffers and provide a =magit= 
like user-interface.
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind (("C-x C-b" . 'ibuffer)))
#+END_SRC
** iedit
#+BEGIN_SRC emacs-lisp
(use-package iedit)
#+END_SRC
** Line numbers
=Emacs= has the minor mode for showing line numbers but it is not enabled by default so let's enable
it to show line numbers every where.
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode 1)
#+END_SRC
** Column number mode
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
** Cursor shape
Emacs default cursor is in the shape of the box and it covers the current char under it so 
let's change it. 
#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

** Current line highlight
Only personal preference no factual reason behind it.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC
** Stop blinking cursor
It distracts my eyes.
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC
** Multiple cursors support
I'm not a fan of multiple cursors myself but sometimes they are the simplest way possible.
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind (("C->" . 'mc/mark-next-like-this)
	   ("C-<" . 'mc/mark-previous-like-this)
	   ("C-c C-<" . 'mc/mark-all-like-this)
	   ("C-M-," . 'mc/edit-lines)))
#+END_SRC
** Improve Scrolling Experience
#+BEGIN_SRC emacs-lisp
(setq jit-lock-defer-time 0.05)
(setq fast-but-imprecise-scrolling t)
#+END_SRC
** Highlight Indents
This is a must have for me when I'm reading/writing yaml files since I always lose track
of where I am in the data tree.
#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :hook ((yaml-mode) . highlight-indent-guides-mode)
  :init
  (setq highlight-indent-guides-method 'character)
  :config
  (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces))
#+END_SRC
** Ace window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind (("C-x o" . 'ace-window) 
	   ("C-x C-o" . 'ace-window)))
#+END_SRC
** Header for new files
Emacs comes with a package called =auto-insert= which inserts headers for new files when you
create them.
#+BEGIN_SRC emacs-lisp
(auto-insert-mode 1)
#+END_SRC
** ripgrep (Better faster grep)
Emacs users always had the goal of living inside Emacs, and how you can live inside Emacs 
without =grep=.
#+BEGIN_SRC emacs-lisp
(use-package rg
  :config
  (rg-enable-default-bindings))
#+END_SRC
** Tags
If you are familiar with =ctags= you know how much power lies behind
such a simple program, while some language servers are not ready for big projects
(talking to you gopls) I am going to have ctags feature in my Emacs.
#+BEGIN_SRC emacs-lisp
  (defun update-ctags ()
    "Update Ctags file in current directory."
    (interactive)
    (cd default-directory)
    (start-process "ctags" "*CTAGS*" "ctags" "-eR" "."))
(global-set-key (kbd "C-x C-r") 'update-ctags)

#+END_SRC
** FZF (fuzzy-file-finder)
#+BEGIN_SRC emacs-lisp
  (use-package fzf
    :bind(("<f3>" . 'fzf)))
#+END_SRC
** Org-mode
#+BEGIN_SRC emacs-lisp
  (eval-and-compile 'org
		    (require 'ox-md)
		    (require 'ox-html))

  (use-package org-bullets
    :hook ((org-mode) . 'org-bullets-mode))

#+END_SRC
* Themes, Icons
** Themes
Let's install some themes :) and ofcourse use one of them.
#+BEGIN_SRC emacs-lisp
(use-package doom-themes :defer t)
(use-package spacemacs-theme :defer t)
(use-package badwolf-theme :defer t)
(use-package modus-operandi-theme :defer t)
(use-package modus-vivendi-theme :defer t)
(load-theme 'modus-vivendi t)
#+END_SRC
** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
(use-package all-the-icons-dired
  :init
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
* Development Environment
** Syntax checker and linter
Syntax checking in my Emacs happens with the help of =Flycheck=, which does the linting
and shows warnings or errors about the code and major modes can hook into it and provide
language specific comments. I enable flycheck for all programming languages using =prog-mode=
hook which basically covers all programming major modes.
#+BEGIN_SRC emacs-lisp
(use-package flycheck :hook (prog-mode . flycheck-mode))
#+END_SRC
** Code Completion
=Company-mode= in Emacs is the package I use to add code-completion to my Emacs.
It's neat package with great architecture, basically =company= is made from two parts
=company-backends= and =company-frontend=, =company-backends= are a list of backends 
and backends are modules that can provide company with completion candidates and 
=company-frontend= is how company shows those completions to me which I use the default
one.
#+BEGIN_SRC emacs-lisp
(use-package company
  :config
  (global-company-mode t)
  (setq company-tooltip-limit 30)
  (setq company-idle-delay .1)
  (setq company-echo-delay 0)
  (add-to-list 'company-backends '(company-capf company-dabbrev)))

#+END_SRC

*** Language Server Protocol
=Company= gives us the infrastructre that we need for code completion but we need
backends to feed it the completion candidates. There are specific backends for almost 
all languages but I use LSP for everything, =LSP= or =LanguageServerProtocol= is a protocol
developed by microsoft for =VSCode= but it's not limited to Microsoft and now it has huge
community, multiple enterprises like =RedHat= and =Sourcegraph= behind it and support
for almost all languages.
[[List of supported langauges][https://langserver.org/#implementations-server]] 
[[https://github.com/emacs-lsp/lsp-mode#supported-languages]]
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :hook
    ((go-mode python-mode php-mode clojure-mode elixir-mode haskell-mode csharp-mode fsharp-mode)
   . #'lsp-deferred))

  (use-package lsp-treemacs
    :commands (lsp-treemacs-errors-list))

  (use-package lsp-ui
    :commands (lsp-ui-mode))

  ;; company backend to hook LSP to company
  (use-package company-lsp
    :config
    (setq company-lsp-cache-candidates 'auto)
    :commands (company-lsp))


#+END_SRC
** Jumping to defenition
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :bind
    (("C-M-j" . 'dumb-jump-go)
     ("C-M-p" . 'dumb-jump-back))
    :config
    (dumb-jump-mode 1))
#+END_SRC
** Git
=magit= is the git wrapper I have seen out then, I have seen =vim-fugitive=, Jetbrains
IDEs git plugin, VSCode git plugin + gitlens, but still =magit= is the best.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands (magit-status)
    :bind
    (("C-x g" . 'magit-status)))

  (use-package diff-hl :config (global-diff-hl-mode 1))

  (use-package gitconfig-mode :mode "/\\.gitconfig\\'")

  (use-package gitignore-mode
    :mode "/\\.gitignore\\'")

  (use-package gitattributes-mode
    :mode "/\\.gitattributes\\'")

  (use-package git-messenger
    :bind
    (("C-M-c" . 'git-messenger:popup-message))
    :config
    (setq git-messenger:show-detail t)
    (setq git-messenger:use-magit-popup t))

#+END_SRC
** Programming Languages
Support for every programming language I have ever used.
#+BEGIN_SRC emacs-lisp
(use-package cquery :defer t)

(use-package mips-mode :defer t)

(use-package fsharp-mode :mode "\\.fs\\'")

(use-package csharp-mode :mode "\\.cs\\'")

(use-package nasm-mode :defer t)

(use-package haxor-mode :mode "\\.hax\\'")

(use-package json-mode
  :mode "\\.json\\'"
  :config
  (add-hook 'before-save-hook 'json-mode-beautify))

(use-package yaml-mode
  :mode
  "\\.ya?ml\\'")

(use-package toml-mode
  :mode "\\.toml\\'")

(use-package csv-mode
  :mode "\\.csv\\'")

(use-package protobuf-mode
  :mode "\\.proto\\'")


(use-package markdown-mode
  :mode "\\.md\\'")


(use-package go-mode
  :mode "\\.go\\'"
  :init
  (add-hook 'go-mode-hook (lambda () (add-to-list 'exec-path (concat (getenv "HOME") "/go/bin"))))
  :config
  (add-hook 'before-save-hook 'gofmt-before-save)
  (add-hook 'before-save-hook 'go-import-add)
  (add-hook 'before-save-hook 'go-remove-unused-import)
  (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))

(use-package go-add-tags :defer t)

(use-package gotest :defer t)


(use-package haskell-mode
  :mode "\\.hs\\'")

(use-package lsp-haskell
  :hook haskell-mode)

(use-package scala-mode
  :mode "\\.scala\\'")

(use-package sbt-mode
  :hook scala-mode)

(use-package python-mode
  :mode "\\.py\\'")


(use-package lsp-python-ms
  :hook (python-mode))


(use-package py-autopep8
  :hook python-mode)

(use-package jinja2-mode
  :mode "\\.j2$")

(use-package elixir-mode
  :mode "\\.ex\\'")

(use-package alchemist
  :defer t)

(use-package rust-mode
  :mode "\\.rs\\'")

(use-package flycheck-rust
 :mode "\\.rs\\'"
 :init (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
 :hook rust-mode)

(use-package cargo
  :mode "\\.rs\\'"
  :init (add-hook 'rust-mode-hook #'cargo-minor-mode))


(use-package paredit
 :hook ((emacs-lisp-mode clojure-mode) . paredit-mode))


(use-package parinfer
  :hook ((emacs-lisp-mode clojure-mode) . parinfer-mode))

(use-package rainbow-delimiters
  :hook ((prog-mode) . rainbow-delimiters-mode))

(use-package clojure-mode
  :mode "\\.cljs?\\'")

(use-package cider
  :mode "\\.cljs?\\'"
  :bind (:map cider-mode-map
	      ("C-x C-e" . 'cider-eval-last-sexp)))

(use-package lua-mode
  :mode "\\.lua\\'")

(use-package php-mode
  :mode "\\.php\\'")

(use-package phpunit
  :bind
  (("C-c C-t t" . phpunit-current-test)
   ("C-c C-t c" . phpunit-current-class)
   ("C-c C-t p" . phpunit-current-project)))

(use-package js2-mode
  :hook js-mode)

(use-package tide
  :mode "\\.ts\\'")

(use-package web-mode
  :mode ("\\.html\\'" "\\.css\\'"))

(use-package dockerfile-mode
  :mode "Dockerfile")

(use-package groovy-mode
  :mode ("\\.gradle\\'" "\\.groovy\\'"))

(use-package gradle-mode
  :mode "\\.gradle\\'")

(add-hook 'java-mode-hook (lambda ()
			    (c-set-offset 'arglist-intro '+)
			    (setq java-basic-offset 2)
			    (setq c-basic-offset 2)))

(use-package lsp-java
  :hook (java-mode))

(use-package racket-mode
  :mode "\\.rkt\\'")


#+END_SRC
* Operations Environment
Recently I started using Emacs for opertion tasks.
#+BEGIN_SRC emacs-lisp
  (use-package kubel
    :commands
    (kubel))

  (use-package docker
    :bind
    ("C-c d" . docker))

  (use-package ansible
    :init
    (add-hook 'yaml-mode-hook (lambda () (ansible))))

#+END_SRC
* Window manager
Emacs is so extensible that you can use it as a X window manager using =exwm= package which is a wrapper around =xeldb=.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :disabled t
    :config
    (require 'exwm)
    (require 'exwm-config)
    (exwm-config-default)
    (display-battery-mode 1)
    (defun exwm-current-workspace ()
      (interactive)
      (message "Current workspace is %s" exwm-workspace-current-index))
    (add-hook 'exwm-workspace-switch-hook 'exwm-current-workspace)
    :bind
    (("C-c C-w n" . 'exwm-current-workspace)
     ("C-x /" . 'exwm-input-toggle-keyboard)))

#+END_SRC
