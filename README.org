* Introduction
This document contains my configuration on vanilla =Emacs= using the principles of =Literate Programming=.
Literate programming allows us to be more expressive and deliberate.
Not only we can use typography to its maximum potential,
but can also employ techniques such as internal links between sections.
This makes the end product much better for end users, than a terse script.
This document is created using =Org-mode= which now ships with =Emacs= as a built-in mode.

* Basic setup
** Package manager setup
#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))

;; Initialise the packages, avoiding a re-initialisation.
(unless (bound-and-true-p package--initialized)
  (setq package-enable-at-startup nil)
  (package-initialize))

#+END_SRC
** Install use-package
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

(eval-when-compile
  (require 'use-package))

#+END_SRC
** Tweak GC
#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :config
    (setq gcmh-idle-delay 10
	  gcmh-high-cons-threshold 16777216
	  gc-cons-percentage 0.1))
#+END_SRC
** Empty file handlers variable at startup
#+BEGIN_SRC emacs-lisp
(defvar --file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(add-hook 'emacs-startup-hook
	  (lambda ()
	    (setq file-name-handler-alist --file-name-handler-alist)))
#+END_SRC
** Start in fundamental mode
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'fundamental-mode)
#+END_SRC

** Disable GUI shits
Emacs GUI starts up with a =menu-bar=, =tool-bar= and =scroll-bar= which I think literally 
nobody is using.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
(scroll-bar-mode 0)
(menu-bar-mode 0)
(setq use-dialog-box nil)
#+END_SRC
** Turn off startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen 0)
#+END_SRC
** Prevent Emacs from medling with =init.el=
=Emacs= has a package called =Customize= which stores some information about the theme, and installed packages
in the init.el file but I put all my emacs configuration in a git repo so I need to prevent this
from happening. 
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
#+END_SRC
** Turn off annoying ring
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
** Font settings
I don't have a default font but I use =Jetbrains Mono=, =Fira Code= and =Hack= font 
almost all the time.
#+BEGIN_SRC emacs-lisp
  (defun amirreza/font (font size)
    (add-to-list 'default-frame-alist (cons 'font (format "%s-%d" font size))))
(amirreza/font "Jetbrains Mono" 12)
#+END_SRC

** y-or-n
Emacs asks yes/no questions in minibuffer an you need to type yes or no completely which
is kind of annoying.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Use PATH from OS
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell :config (exec-path-from-shell-initialize))
#+END_SRC
* Themes, Icons
** Themes
Let's install some themes :) and ofcourse use one of them.
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes :defer t)
  (use-package spacemacs-theme :defer t)
  (use-package badwolf-theme :defer t)
  (use-package modus-operandi-theme :defer t) ;; light version of modus theme
  (use-package modus-vivendi-theme :defer t) ;; dark version of modus theme
  (load-theme 'doom-one t)

#+END_SRC
** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
(use-package all-the-icons-dired
  :init
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
** Modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :init (doom-modeline-mode 1))
(setq doom-modeline-height 35)
#+END_SRC
* Completion and narrowing framework
** Code Completion
=Company-mode= in Emacs is the package I use to add code-completion to my Emacs.
It's neat package with great architecture, basically =company= is made from two parts
=company-backends= and =company-frontend=, =company-backends= are a list of backends 
and backends are modules that can provide company with completion candidates and 
=company-frontend= is how company shows those completions to me which I use the default
one.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (global-company-mode 1)
    (setq company-tooltip-limit 30)
    (setq company-idle-delay .1)
    (setq company-echo-delay 0)
    (add-to-list 'company-backends '(company-capf company-dabbrev)))

#+END_SRC
** Ivy
When using =Emacs= a task you probably do a thousand times is to find something in =minibuffer= 
out of multiple choices that you have, basic =Emacs= is not that productive because of that there
are multiple packages in community that help you do these kind of tasks simpler, the one that I
use daily is called =ivy= which is basically a framework for narrowing down candidates, but it comes
with a general frontend called =counsel= which provides replacement functions for default Emacs 
functions like =find-file= and others you can see the ones I use in the code block below and
a =C-s= replacement tool call swiper.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :bind
    (("C-x b" . 'ivy-switch-buffer)))

  (use-package ivy-posframe
    :disabled t
    :config
    (setq ivy-posframe-height-alist
	  '((swiper . 15)
	    (swiper-isearch . 15)
	    (t . 10)))
    (setq ivy-posframe-display-functions-alist
	  '((swiper . nil)
	    (swiper-isearch . nil)
	    (t . ivy-posframe-display-at-frame-center)))
    (ivy-posframe-mode 1))

  (use-package swiper
    :commands (swiper)
    :init (global-set-key (kbd "C-s") 'swiper))

  (use-package counsel
    :commands (counsel-M-x counsel-find-file ivy-switch-buffer)
    :bind
    (("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("C-h b" . 'counsel-descbinds)
     ("C-h f" . 'counsel-describe-function)
     ("C-h v" . 'counsel-describe-variable)
     ("C-h a" . 'counsel-apropos)
     ("<f4>"  . 'counsel-fzf)
     ("M-y" . 'counsel-yank-pop)))

#+END_SRC
** Icomplete
=Icomplete= is probably the oldest completion framework out there, it was first released in the 90s and out of the box it can not compete with other options like =Ido= or third 
party ones like =Ivy= or =Helm=. To get the best possible result from =Icomplete= we need to customize the =minibuffer= as well.
#+BEGIN_SRC emacs-lisp
  (use-package minibuffer
    :disabled ;; somehow it screws company mode :)
    :ensure nil
    :config
    (setq completion-casere-case t)
    (setq completion-styles '(flex))) ;; emacs 27 only

  (use-package icomplete
    :disabled t
    :config
    (icomplete-mode 1))
#+END_SRC
** Ido
Ido mode is a built-in completion and narrowing framework for Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package ido
    :disabled t
    :config
    (ido-mode 1)
    (ido-everywhere 1)
    (setq ido-enable-flex-matching t))

  (use-package ido-at-point
    :disabled t
     :config
     (ido-at-point-mode 1)
     (global-set-key (kbd "M-;") 'completion-at-point))

  (use-package ido-vertical-mode
    :disabled t
    :config
    (ido-vertical-mode 1)
    (setq ido-vertical-define-keys 'C-n-and-C-p-only))

  (use-package ido-completing-read+
    :disabled t
    :config
    (ido-ubiquitous-mode 1))
#+END_SRC
* Improve general editor experience
** General keybindings
#+BEGIN_SRC emacs-lisp
  ;; disabling some useless annoying keys
  (global-set-key (kbd "C-z") nil)
  (global-set-key (kbd "M-z") nil)
  (global-set-key (kbd "C-x C-z") nil)

  ;; sane zoom-in and zoom-out 
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C-_") 'text-scale-decrease)
#+END_SRC
** Which Key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode 1))
#+END_SRC
** Custom motions
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-n") (lambda () (interactive) (next-line 5)))
  (global-set-key (kbd "M-p") (lambda () (interactive) (previous-line 5)))
#+END_SRC
** Treemacs
Modern tree file browser.
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :bind (("<f8>" . treemacs))) ;; toggles the treemacs
  (use-package treemacs-projectile)
  (use-package treemacs-magit)
#+END_SRC
** Buffer switching (ibuffer)
Emacs built-in funtion called =list-buffers= is not that much productive, luckily Emacs now ships
with =Ibuffer= package which is an interactive way to manage you buffers and provide a =magit= 
like user-interface.
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind (("C-x C-b" . 'ibuffer)))
  (use-package ibuffer-vc :disabled t)
#+END_SRC
** Dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :bind
    (("C-x C-j" . dired-jump)
     ("C-x j" . dired-jump-other-window))
    :custom
    ;; Always delete and copy recursively
    (dired-recursive-deletes 'always)
    (dired-recursive-copies 'always))
#+END_SRC
** Winner mode
#+BEGIN_SRC emacs-lisp
  (use-package winner 
    :ensure nil)
#+END_SRC
** IEdit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :bind (("C-;" . 'iedit-mode)))
#+END_SRC
** Crux
Crux is a collection of useful emacs functions.
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :bind (("C-S-k" . 'crux-kill-whole-line)
	   ("C-x K" . 'crux-kill-other-buffers)))
#+END_SRC
** Line numbers
=Emacs= has the minor mode for showing line numbers but it is not enabled by default so let's enable
it to show line numbers every where.
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode 1)
#+END_SRC
** Column number mode
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
** Cursor shape
Emacs default cursor is in the shape of the box and it covers the current char under it so 
let's change it. 
#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

** Current line highlight
Only personal preference no factual reason behind it.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC
** Stop blinking cursor
It distracts my eyes.
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC
** Multiple cursors support
I'm not a fan of multiple cursors myself but sometimes they are the simplest way possible.
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind (("C->" . 'mc/mark-next-like-this)
	   ("C-<" . 'mc/mark-previous-like-this)
	   ("C-c C-<" . 'mc/mark-all-like-this)
	   ("C-M-," . 'mc/edit-lines)))
#+END_SRC
** Expand region
expand region is package that helps you expand/ a selected text region based
on semantics.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("C-=" . 'er/expand-region)
	   ("C--" . 'er/contract-region)))
#+END_SRC
** Improve Scrolling Experience
#+BEGIN_SRC emacs-lisp
;; Vertical Scroll
(setq scroll-step 1)
(setq scroll-margin 1)
(setq scroll-conservatively 101)
(setq scroll-up-aggressively 0.01)
(setq scroll-down-aggressively 0.01)
(setq auto-window-vscroll nil)
(setq fast-but-imprecise-scrolling nil)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-progressive-speed nil)
;; Horizontal Scroll
(setq hscroll-step 1)
(setq hscroll-margin 1)
#+END_SRC
** Highlight Indents
This is a must have for me when I'm reading/writing yaml files since I always lose track
of where I am in the data tree.
#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :hook ((yaml-mode) . highlight-indent-guides-mode)
  :init
  (setq highlight-indent-guides-method 'character)
  :config
  (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces))
#+END_SRC
** Ace window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind (("C-x o" . 'ace-window) 
	   ("C-x C-o" . 'ace-window)))
#+END_SRC
** Header for new files
Emacs comes with a package called =auto-insert= which inserts headers for new files when you
create them.
#+BEGIN_SRC emacs-lisp
(auto-insert-mode 1)
#+END_SRC
** Ripgrep (Better faster grep)
Emacs users always had the goal of living inside Emacs, and how you can live inside Emacs 
without =grep=. I'm using counsel-projectile-rg instead of this but it's here for percaution.
#+BEGIN_SRC emacs-lisp
  (use-package rg
    :commands (rg))
#+END_SRC
** cTags
If you are familiar with =ctags= you know how much power lies behind
such a simple program, while some language servers are not ready for big projects
(talking to you gopls) I am going to have ctags feature in my Emacs.
#+BEGIN_SRC emacs-lisp
  (defun update-ctags ()
    "Update Ctags file in current directory."
    (interactive)
    (cd default-directory)
    (start-process "ctags" "*CTAGS*" "ctags" "-eR" "."))
#+END_SRC
** FZF (fuzzy-file-finder)
Fuzzy file search, but I use =counsel-fzf= since it has the best match for all of my workflow.
#+BEGIN_SRC emacs-lisp
  (use-package fzf
    :commands (fzf)
    :bind(("<f3>" . 'fzf)))
#+END_SRC
** Sudo edit
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :commands (sudo-edit))
#+END_SRC
** Org-mode
#+BEGIN_SRC emacs-lisp
  (use-package org
    :config
    (require 'ox-md)
    (require 'ox-html)
    (setq org-support-shift-select t))

  (use-package org-bullets
    :hook ((org-mode) . 'org-bullets-mode))

  (use-package toc-org)
#+END_SRC
* Development Environment
** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind
    (("C-x p" . 'projectile-command-map)
     ("C-c p" . 'projectile-add-known-project))
    :custom
    (projectile-completion-system 'ivy)
    :config
    (projectile-mode 1)
    (add-to-list 'projectile-globally-ignored-directories "node_modules"))

  (use-package counsel-projectile
    :bind (("<f2>" . counsel-projectile-rg)))

#+END_SRC
** Syntax checker and linter
Syntax checking in my Emacs happens with the help of =Flycheck=, which does the linting
and shows warnings or errors about the code and major modes can hook into it and provide
language specific comments. I enable flycheck for all programming languages using =prog-mode=
hook which basically covers all programming major modes.
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (flymake-mode 0)))

(use-package flycheck :hook (prog-mode . flycheck-mode))
#+END_SRC
** Language Server Protocol
=Company= gives us the infrastructre that we need for code completion but we need
backends to feed it the completion candidates. There are specific backends for almost 
all languages but I use LSP for everything, =LSP= or =LanguageServerProtocol= is a protocol
developed by microsoft for =VSCode= but it's not limited to Microsoft and now it has huge
community, multiple enterprises like =RedHat= and =Sourcegraph= behind it and support
for almost all languages.
[[List of supported langauges][https://langserver.org/#implementations-server]] 
[[https://github.com/emacs-lsp/lsp-mode#supported-languages]]
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :hook ((prog-mode) . lsp)
    :commands
    (lsp))

  (use-package lsp-treemacs
    :commands (lsp-treemacs-errors-list))

  (use-package lsp-ui
    :commands (lsp-ui-mode))

  ;; company backend to hook LSP to company
  (use-package company-lsp
    :config
    (setq company-lsp-cache-candidates 'auto)
    :commands (company-lsp))


#+END_SRC
** Dumb jump
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :bind
    (("C-M-j" . 'dumb-jump-go)
     ("C-M-p" . 'dumb-jump-back))
    :config
    (dumb-jump-mode 1))
#+END_SRC
** Git
=magit= is the git wrapper I have seen out then, I have seen =vim-fugitive=, =Jetbrains
IDEA=, =VSCode+Gitlens=, but still =magit= is the best.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands (magit-status)
    :bind
    (("C-x g" . 'magit-status)))

  (use-package diff-hl :config (global-diff-hl-mode 1))

  (use-package gitconfig-mode :mode "/\\.gitconfig\\'")

  (use-package gitignore-mode
    :mode "/\\.gitignore\\'")

  (use-package gitattributes-mode
    :mode "/\\.gitattributes\\'")

  (use-package git-messenger
    :bind
    (("C-M-c" . 'git-messenger:popup-message))
    :config
    (setq git-messenger:show-detail t)
    (setq git-messenger:use-magit-popup t))

#+END_SRC
** Programming Languages
Support for every programming language I have ever used.
#+BEGIN_SRC emacs-lisp
  (use-package cquery :defer t)

  (use-package mips-mode :defer t)

  (use-package fsharp-mode :mode "\\.fs\\'")

  (use-package csharp-mode :mode "\\.cs\\'")

  (use-package nasm-mode :defer t)

  (use-package haxor-mode :mode "\\.hax\\'")

  (use-package json-mode
    :mode "\\.json\\'"
    :config
    (add-hook 'before-save-hook 'json-mode-beautify))

  (use-package yaml-mode
    :mode
    "\\.ya?ml\\'")

  (use-package toml-mode
    :mode "\\.toml\\'")

  (use-package csv-mode
    :mode "\\.csv\\'")

  (use-package protobuf-mode
    :mode "\\.proto\\'")


  (use-package markdown-mode
    :mode "\\.md\\'")


  (use-package go-mode
    :mode "\\.go\\'"
    :init
    (add-hook 'go-mode-hook (lambda () (add-to-list 'exec-path (concat (getenv "HOME") "/go/bin"))))
    :config
    (add-hook 'before-save-hook 'gofmt-before-save)
    (add-hook 'before-save-hook 'go-import-add)
    (add-hook 'before-save-hook 'go-remove-unused-import)
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))

  (use-package go-add-tags :defer t)

  (use-package gotest :defer t)


  (use-package haskell-mode
    :mode "\\.hs\\'")

  (use-package lsp-haskell
    :hook haskell-mode)

  (use-package scala-mode
    :mode "\\.scala\\'")

  (use-package sbt-mode
    :hook scala-mode)

  (use-package python-mode
    :mode "\\.py\\'")

  (use-package pipenv
    :defer t)

  (use-package lsp-python-ms
    :defer t)

  (use-package py-autopep8
    :hook python-mode)

  (use-package jinja2-mode
    :mode "\\.j2$")

  (use-package elixir-mode
    :mode "\\.ex\\'")

  (use-package alchemist
    :defer t)

  (use-package rust-mode
    :mode "\\.rs\\'")

  (use-package flycheck-rust
   :mode "\\.rs\\'"
   :init (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
   :hook rust-mode)

  (use-package cargo
    :mode "\\.rs\\'"
    :init (add-hook 'rust-mode-hook #'cargo-minor-mode))


  (use-package paredit
   :hook ((emacs-lisp-mode clojure-mode) . paredit-mode))


  (use-package parinfer
    :hook ((emacs-lisp-mode clojure-mode) . parinfer-mode))

  (use-package rainbow-delimiters
    :hook ((prog-mode) . rainbow-delimiters-mode))

  (use-package clojure-mode
    :mode "\\.cljs?\\'")

  (use-package cider
    :mode "\\.cljs?\\'"
    :bind (:map cider-mode-map
		("C-x C-e" . 'cider-eval-last-sexp)))

  (use-package lua-mode
    :mode "\\.lua\\'")

  (use-package php-mode
    :mode "\\.php\\'")

  (use-package phpunit
    :bind
    (("C-c C-t t" . phpunit-current-test)
     ("C-c C-t c" . phpunit-current-class)
     ("C-c C-t p" . phpunit-current-project)))

  (use-package js2-mode
    :hook js-mode)

  (use-package tide
    :mode "\\.ts\\'")

  (use-package web-mode
    :mode ("\\.html\\'" "\\.css\\'"))

  (use-package dockerfile-mode
    :mode "Dockerfile")

  (use-package groovy-mode
    :mode ("\\.gradle\\'" "\\.groovy\\'"))

  (use-package gradle-mode
    :mode "\\.gradle\\'")

  (add-hook 'java-mode-hook (lambda ()
			      (c-set-offset 'arglist-intro '+)
			      (setq java-basic-offset 2)
			      (setq c-basic-offset 2)))

  (use-package lsp-java
    :hook (java-mode))

  (use-package racket-mode
    :mode "\\.rkt\\'")


#+END_SRC
* Operations Environment
Recently I started using Emacs for opertion tasks.
#+BEGIN_SRC emacs-lisp
  (use-package kubel
    :commands
    (kubel))

  (use-package docker
    :bind
    ("C-c d" . docker))

  (use-package ansible
    :init
    (add-hook 'yaml-mode-hook (lambda () (ansible))))

#+END_SRC
* Gnus setup
Emacs =Gnus= basic setup for Gmail.
#+BEGIN_SRC emacs-lisp
  (setq user-mail-address "raskarpour@gmail.com"
	user-full-name "amirrezaask")

  (setq gnus-select-method
	'(nnimap "gmail"
		 (nnimap-address "imap.gmail.com")  ; it could also be imap.googlemail.com if that's your server.
		 (nnimap-server-port "imaps")
		 (nnimap-stream ssl)))
  (setq smtpmail-smtp-server "smtp.gmail.com"
	smtpmail-smtp-service 587
	gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

#+END_SRC
* Window manager
Emacs is so extensible that you can use it as a X window manager using =exwm= package which is a wrapper around =xeldb=.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :disabled t
    :config
    (require 'exwm)
    (require 'exwm-config)
    (exwm-config-default)
    (display-battery-mode 1)
    (defun exwm-current-workspace ()
      (interactive)
      (message "Current workspace is %s" exwm-workspace-current-index))
    (add-hook 'exwm-workspace-switch-hook 'exwm-current-workspace)
    :bind
    (("C-c C-w n" . 'exwm-current-workspace)
     ("C-x /" . 'exwm-input-toggle-keyboard)))

#+END_SRC

